# 介绍

Rspack 是一个基于 Rust 的高性能构建引擎，其提供了对 Webpack 生态良好的兼容支持。

## 为什么选择 Rspack

我们创建 Rspack 是为了解决我们在维护公司构建工具时碰到的各种性能问题，并且市面上并没有工具能够良好的解决这些问题。

### 为什么没选择 bundleless

bundleless 很好的解决了开发性能问题，但是同时也引入了其他问题，一方面在在一些大型仓库下，首屏可能存在几千个网络请求，这导致虽然 cli 可以快速的启动，但是首屏展示仍然耗时很长，另一方面其生产环境优化相比于 webpack 仍然有较大差距，难以适用于一些对拆包策略敏感的应用，另外对于一些大型应用，生产环境构建耗时也是个非常敏感的指标，这些 bundleless 工具虽然很好的解决了 dev 性能问题，但是生产环境构建的性能仍然难以满足要求。

### 为什么没选择 esbuild

我们在内部大规模的实践过 esbuild 作为 通用 Webapp 的构建工具，但是其如下一些问题导致其难以满足我们的需求，

- 缺乏对 HMR 和 增量编译的良好支持，这导致大型项目中其 HMR 性能比较低下
- 拆包策略也非常原始，难以满足业务复杂多变的拆包需求。

正是受限于上述的一些工具的限制，我们觉得从零构建一个 Rust Bundler 是一个更好的选择。

## Rspack 为什么比 Webpack 快

Rspack 比 Webpack 快得益于如下几方面

- Rust 语言优势: Rspack 使用 Rust 语言编写， 得益于 Rust 的高性能编译器支持， Rust 编译生成的 Native Code 通常比 JavaScript 性能更为高效。
- 高度并行的架构: Webpack 受限于 Javascript 对多线程的羸弱支持，导致其很难进行高度的并行化计算，而得益于 Rust 语言的并行化的良好支持， Rspack 采用了高度并行化的架构，如模块图生成，代码生成等阶段，都是采用多线程并行执行，这使得其编译性能随着 CPU 核心数的增长而增长，充分挖掘 CPU 的多核优势。
- 内置大部分的功能: 事实上 Webpack 本身的性能足够高效，但是因为 webpack 本身内置了较少的功能，这使得我们在使用 Webpack 做现代 Webapp 开发时，通常需要配合很多的 plugin 和 loader，
  而这些 loader 和 plugin 往往是性能的瓶颈，而 Rspack 虽然支持 Loader 和 Plugin，但是保证绝大部分常用功能都内置在 Rspack 内，从而减小 JS Plugin | Loader 导致的低性能和通信开销问题。
- 增量编译: 尽管 Rspack 的全量编译足够高效，但是当项目庞大时，全量的编译仍然难以满足 HMR 的性能要求，因此在 HMR 阶段，我们采用的是更为高效的增量编译策略，从而保证，无论你的项目多大，其 HMR 的开销总是控制在合理范围内。

## 为什么兼容 Webpack

Webpack 作为目前使用率最高的工具，其架构、产物质量和灵活性久经考验，另一方面大量的框架和社区生态都是基于 Webpack，包括公司内部也有大量的框架和工具都是基于 Webpack，一方面从零再造一个生态并不容易，另一方面上层的框架从一个构建工具切换到另一个工具链也绝非易事，为了更好的帮助上层框架和周边生态，渐进式的向 Rust 生态迁移，同时我们也从 vite 兼容 rollup 生态的成功历史经验学习到，觉得兼容 Webpack 生态是一个不错的选择。
